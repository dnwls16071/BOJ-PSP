# 모든 값이 0으로 채워져 있는 길이가 N인 배열 A가 있다. 영선이는 다음과 같은 두 연산을 수행할 수 있다.
#
# 배열에 있는 값 하나를 1 증가시킨다.
# 배열에 있는 모든 값을 두 배 시킨다.
# 배열 B가 주어졌을 때, 배열 A를 B로 만들기 위한 연산의 최소 횟수를 구하는 프로그램을 작성하시오.

N = int(input())
A = [0] * N  # [0 0]
B = list(map(int, input().split()))  # [2 1]

cnt = 0    # 연산 횟수
while sum(B) != 0:
    flag = 0    # 플래그값
    for i in range(N):
        if B[i] % 2 != 0 or B[i] == 0 or B[i] == 1:
            if B[i] == 0:
                continue
            else:
                B[i] -= 1
                cnt += 1
            flag = 1
    if flag == 0:    # 만약 플래그값이 0이면? => 모든 수가 다 짝수이면?
        for i in range(N):
            B[i] //= 2
        cnt += 1
print(cnt)

# 전에 풀었던 그리디 알고리즘 문제가 생각났다.
# 이런 유형의 문제는 역발상이 가장 좋은 방법이 된다.

# 배열의 합이 0, 즉 모든 수가 0이 된다면 반복문을 멈춘다.
# 배열의 모든 수가 짝수라면 전부 다 2로 나눠주고 연산횟수를 1만큼 증가시킨다.
# 배열의 특정 수가 홀수라면 1을 빼준다.




