# 상근이가 살고있는 동네에는 빌딩 N개가 한 줄로 세워져 있다. 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 같은 높이를 가지는 빌딩은 없다. 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았다.
#
# 상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에, 빌딩이 어떤 순서로 위치해있는지는 알 수가 없다.
#
# 빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때, 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.
#
# 예를 들어, N = 5, L = 3, R = 2인 경우에 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다.

N, L, R = map(int, input().split())
num = 1000000007
building = [[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]
building[1][1][1] = 1
for a in range(2, N+1):
    for b in range(1, L+1):
        for c in range(1, R+1):
            # 만약 N, L, R 세 개의 값 중에서 하나라도 0이 나오면 그 값은 0이 된다.
            if a == 0 or b == 0 or c == 0:
                building[a][b][c] = 0
            building[a][b][c] = building[a-1][b-1][c] + building[a-1][b][c-1] + building[a-1][b][c] * (a-2)
print(building[N][L][R] % num)

# 규칙성을 파악해서 점화식을 살짝 어거지로 끼워맞춘감이 없지않아 있었던 문제였다.