# 상근이는 창고에서 링 N개를 발견했다. 상근이는 각각의 링이 앞에 있는 링과 뒤에 있는 링과 접하도록 바닥에 내려놓았다.
#
# 상근이는 첫 번째 링을 돌리기 시작했고, 나머지 링도 같이 돌아간다는 사실을 발견했다. 나머지 링은 첫 번째 링 보다 빠르게 돌아가기도 했고, 느리게 돌아가기도 했다. 이렇게 링을 돌리다 보니 첫 번째 링을 한 바퀴 돌리면, 나머지 링은 몇 바퀴 도는지 궁금해졌다.
#
# 링의 반지름이 주어진다. 이때, 첫 번째 링을 한 바퀴 돌리면, 나머지 링은 몇 바퀴 돌아가는지 구하는 프로그램을 작성하시오.

N = int(input())
ring_size = list(map(int, input().split()))

def GCD(a, b):
    while b != 0:
        remain = a % b
        a = b
        b = remain
    return a

tmp = ring_size.pop(0)
for i in range(N-1):
    num = GCD(tmp, ring_size[i])
    print(str(tmp // num) + "/" + str(ring_size[i] // num))

# 최대 공약수란, 숫자 a, b가 주어졌을 때, 공통되는 약수 중에서 최대값을 의미한다.
# a, b 각각의 약수를 통해서 공통된 약수 중에서 가장 큰 값을 찾는 방법 > 하지만 찾지 않아도 되는 약수들가지 다 찾아야하기에 효율적이지 않다.

# 위의 문제를 해결하기위해 유클리드 호제법을 이용한다.
# 숫자 a, b가 있을 때, a를 b로 나눈 나머지와 b의 최대 공약수는 a와 b의 최대 공약수가 같다는 것을 의미한다.
# b가 0이 될 때까지 반복을 하면, 남는 a값이 최대 공약수가 된다.

# 최소 공배수란, 서로 다른 수 a, b의 배수중에서 공통되는 배수 중에 가장 작은 값을 의미한다.
# 최소공배수는 a,b의 곱을 최대 공약수로 나누면 나오게 된다.

# 유클리드 호제법에 대해서 공부할 수 있었던 문제였다.
# 좋은 알고리즘이고 자주 쓰이는 알고리즘이므로 자주 사용하려고 시도해봐야겠다.